#!/usr/bin/env python3
"""Generate an IDAES GenericParameterBlock configuration template from a JSON spec.

Usage:
    python build_generic_config_template.py --spec spec.json --output my_props.py
"""

from __future__ import annotations

import argparse
import copy
import json
import re
from pathlib import Path
from typing import Any, Dict, Iterable, List, Tuple


def _slug(text: str) -> str:
    return re.sub(r"[^a-zA-Z0-9_]+", "_", text).strip("_").lower() or "custom"


def _normalize_components(raw_components: Any) -> List[str]:
    out: List[str] = []
    if not isinstance(raw_components, list):
        return out
    for item in raw_components:
        if isinstance(item, str):
            out.append(item)
        elif isinstance(item, dict):
            cid = item.get("id") or item.get("name")
            if cid:
                out.append(str(cid))
    return out


def _infer_phase_type(phase_id: str, phase_type: str | None) -> str:
    if phase_type in {"LiquidPhase", "VaporPhase", "SolidPhase"}:
        return phase_type
    pid = phase_id.lower()
    if "liq" in pid:
        return "LiquidPhase"
    if "vap" in pid or "gas" in pid:
        return "VaporPhase"
    if "sol" in pid:
        return "SolidPhase"
    return "VaporPhase"


def _normalize_phases(raw_phases: Any) -> List[Tuple[str, str]]:
    out: List[Tuple[str, str]] = []
    if not isinstance(raw_phases, list):
        return out
    for item in raw_phases:
        if isinstance(item, str):
            out.append((item, _infer_phase_type(item, None)))
        elif isinstance(item, dict):
            pid = item.get("id") or item.get("name")
            if not pid:
                continue
            out.append((str(pid), _infer_phase_type(str(pid), item.get("type"))))
    return out


def _normalize_state_def(spec: Dict[str, Any]) -> str:
    state_def = str(spec.get("state_definition", "FTPx"))
    allowed = {"FTPx", "FpcTP", "FcTP", "FPhx", "FcPh"}
    return state_def if state_def in allowed else "FTPx"


def _normalize_eos_map(spec: Dict[str, Any], phases: Iterable[str]) -> Dict[str, str]:
    eos = spec.get("eos", {})
    phase_to_eos = eos.get("phase_to_eos", {}) if isinstance(eos, dict) else {}
    out: Dict[str, str] = {}
    for ph in phases:
        val = str(phase_to_eos.get(ph, "Ideal")).upper()
        if val in {"PR", "SRK", "IDEAL"}:
            out[ph] = val
        else:
            out[ph] = "IDEAL"
    return out


def _normalize_equilibrium(spec: Dict[str, Any], phases: List[str]) -> Tuple[bool, List[Tuple[str, str]], str]:
    eq = spec.get("equilibrium", {})
    required = bool(eq.get("required", False)) if isinstance(eq, dict) else False
    form = str(eq.get("form", "fugacity")) if isinstance(eq, dict) else "fugacity"

    pairs: List[Tuple[str, str]] = []
    raw_pairs = eq.get("pairs", []) if isinstance(eq, dict) else []
    if isinstance(raw_pairs, list):
        for p in raw_pairs:
            if isinstance(p, (list, tuple)) and len(p) == 2:
                pairs.append((str(p[0]), str(p[1])))

    if required and not pairs and len(phases) >= 2:
        pairs.append((phases[0], phases[1]))

    if form not in {"fugacity", "log_fugacity"}:
        form = "fugacity"
    return required, pairs, form


def _state_bounds_for(state_def: str) -> Dict[str, str]:
    bounds = {
        "temperature": "(250, 300, 1200, pyunits.K)",
        "pressure": "(1e4, 1e5, 1e7, pyunits.Pa)",
    }
    if state_def in {"FTPx", "FPhx"}:
        bounds["flow_mol"] = "(0, 100, 1e4, pyunits.mol/pyunits.s)"
    if state_def in {"FcTP", "FcPh"}:
        bounds["flow_mol_comp"] = "(0, 10, 1e4, pyunits.mol/pyunits.s)"
    if state_def == "FpcTP":
        bounds["flow_mol_phase_comp"] = "(0, 10, 1e4, pyunits.mol/pyunits.s)"
    if state_def in {"FPhx", "FcPh"}:
        bounds["enth_mol"] = "(-1e6, 0, 1e6, pyunits.J/pyunits.mol)"
    return bounds


def _render(spec: Dict[str, Any], include_factory: bool) -> str:
    name = str(spec.get("name", "custom_property_package"))
    components = _normalize_components(spec.get("components", []))
    phases_norm = _normalize_phases(spec.get("phases", []))

    if not components:
        components = ["component_1", "component_2"]
    if not phases_norm:
        phases_norm = [("Vap", "VaporPhase")]

    phase_ids = [p[0] for p in phases_norm]
    state_def = _normalize_state_def(spec)
    eos_map = _normalize_eos_map(spec, phase_ids)
    eq_required, eq_pairs, eq_form = _normalize_equilibrium(spec, phase_ids)

    uses_cubic = any(v in {"PR", "SRK"} for v in eos_map.values())
    uses_ideal = any(v == "IDEAL" for v in eos_map.values())

    lines: List[str] = []
    lines.append('"""')
    lines.append(f"Template generic property package for: {name}")
    lines.append("Generated by create-property-package skill scaffolder.")
    lines.append('"""')
    lines.append("")
    lines.append("import copy")
    lines.append("from pyomo.environ import units as pyunits")
    lines.append("")

    phase_types = sorted(set(t for _, t in phases_norm))
    core_imports = ", ".join([*phase_types, "Component"])
    lines.append(f"from idaes.core import {core_imports}")

    lines.append(
        f"from idaes.models.properties.modular_properties.state_definitions import {state_def}"
    )

    if uses_ideal:
        lines.append("from idaes.models.properties.modular_properties.eos.ideal import Ideal")
    if uses_cubic:
        lines.append("from idaes.models.properties.modular_properties.eos.ceos import Cubic, CubicType")

    if eq_required:
        if uses_cubic:
            lines.append(
                "from idaes.models.properties.modular_properties.phase_equil import CubicComplementarityVLE"
            )
            lines.append(
                "from idaes.models.properties.modular_properties.phase_equil.bubble_dew import LogBubbleDew"
            )
            lines.append(
                "from idaes.models.properties.modular_properties.phase_equil.forms import log_fugacity"
            )
        else:
            lines.append("from idaes.models.properties.modular_properties.phase_equil import SmoothVLE")
            lines.append(
                "from idaes.models.properties.modular_properties.phase_equil.bubble_dew import IdealBubbleDew"
            )
            lines.append(
                "from idaes.models.properties.modular_properties.phase_equil.forms import fugacity"
            )

    lines.append("")
    lines.append("# Add selected pure/transport methods from modular property libraries as needed.")
    lines.append("# Example:")
    lines.append("# from idaes.models.properties.modular_properties.pure import NIST, Perrys, RPP4, RPP5")
    lines.append("")

    lines.append("configuration = {")
    lines.append('    "components": {')
    for comp in components:
        lines.append(f'        "{comp}": {{')
        lines.append('            "type": Component,')
        lines.append('            "elemental_composition": {},  # TODO')
        if eq_required:
            eq_form_name = "log_fugacity" if uses_cubic else "fugacity"
            lines.append(
                f'            "phase_equilibrium_form": {{({repr(eq_pairs[0][0])}, {repr(eq_pairs[0][1])}): {eq_form_name}}},'
            )
        lines.append('            # TODO: Add selected property methods (cp_mol_ig_comp, enth_mol_ig_comp, etc.)')
        lines.append('            "parameter_data": {')
        lines.append('                "mw": (0.0, pyunits.kg/pyunits.mol),  # TODO')
        lines.append('                "pressure_crit": (0.0, pyunits.Pa),  # TODO')
        lines.append('                "temperature_crit": (0.0, pyunits.K),  # TODO')
        lines.append('                "omega": 0.0,  # TODO for cubic EOS')
        lines.append('            },')
        lines.append("        },")
    lines.append("    },")

    lines.append('    "phases": {')
    for phase_id, phase_type in phases_norm:
        eos = eos_map[phase_id]
        lines.append(f'        "{phase_id}": {{')
        lines.append(f"            \"type\": {phase_type},")
        if eos == "IDEAL":
            lines.append('            "equation_of_state": Ideal,')
        else:
            lines.append('            "equation_of_state": Cubic,')
            lines.append(f'            "equation_of_state_options": {{"type": CubicType.{eos}}},')
        lines.append("        },")
    lines.append("    },")

    lines.append('    "base_units": {')
    lines.append('        "time": pyunits.s,')
    lines.append('        "length": pyunits.m,')
    lines.append('        "mass": pyunits.kg,')
    lines.append('        "amount": pyunits.mol,')
    lines.append('        "temperature": pyunits.K,')
    lines.append("    },")

    lines.append(f'    "state_definition": {state_def},')
    lines.append('    "state_bounds": {')
    for key, value in _state_bounds_for(state_def).items():
        lines.append(f'        "{key}": {value},')
    lines.append("    },")
    lines.append('    "pressure_ref": (101325, pyunits.Pa),')
    lines.append('    "temperature_ref": (298.15, pyunits.K),')

    if eq_required and eq_pairs:
        eq_state = "CubicComplementarityVLE" if uses_cubic else "SmoothVLE"
        bd = "LogBubbleDew" if uses_cubic else "IdealBubbleDew"
        lines.append('    "phases_in_equilibrium": [')
        for p1, p2 in eq_pairs:
            lines.append(f'        ("{p1}", "{p2}"),')
        lines.append("    ],")
        lines.append('    "phase_equilibrium_state": {')
        for p1, p2 in eq_pairs:
            lines.append(f'        ("{p1}", "{p2}"): {eq_state},')
        lines.append("    },")
        lines.append(f'    "bubble_dew_method": {bd},')

    if uses_cubic:
        lines.append('    "parameter_data": {')
        cubic_type = "PR" if any(v == "PR" for v in eos_map.values()) else "SRK"
        lines.append(f'        "{cubic_type}_kappa": {{')
        for a in components:
            for b in components:
                lines.append(f'            ("{a}", "{b}"): 0.0,  # TODO')
        lines.append("        },")
        lines.append("    },")

    lines.append("}")

    if include_factory:
        lines.append("")
        lines.append("def get_prop(components=None, phases=None):")
        lines.append("    \"\"\"Return filtered configuration for selected components/phases.\"\"\"")
        lines.append("    cfg = copy.deepcopy(configuration)")
        lines.append("    if components is not None:")
        lines.append("        cfg[\"components\"] = {")
        lines.append("            k: v for k, v in cfg[\"components\"].items() if k in components")
        lines.append("        }")
        lines.append("    if phases is not None:")
        lines.append("        cfg[\"phases\"] = {")
        lines.append("            k: v for k, v in cfg[\"phases\"].items() if k in phases")
        lines.append("        }")
        lines.append("        if \"phases_in_equilibrium\" in cfg:")
        lines.append("            cfg[\"phases_in_equilibrium\"] = [")
        lines.append("                p for p in cfg[\"phases_in_equilibrium\"] if p[0] in phases and p[1] in phases")
        lines.append("            ]")
        lines.append("        if \"phase_equilibrium_state\" in cfg:")
        lines.append("            cfg[\"phase_equilibrium_state\"] = {")
        lines.append("                p: m")
        lines.append("                for p, m in cfg[\"phase_equilibrium_state\"].items()")
        lines.append("                if p[0] in phases and p[1] in phases")
        lines.append("            }")
        lines.append("    return cfg")

    return "\n".join(lines) + "\n"


def main() -> None:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("--spec", required=True, help="Path to normalized JSON spec")
    parser.add_argument("--output", required=True, help="Output Python module path")
    parser.add_argument(
        "--no-factory",
        action="store_true",
        help="Do not emit get_prop helper function",
    )
    args = parser.parse_args()

    spec_path = Path(args.spec)
    out_path = Path(args.output)

    with spec_path.open("r", encoding="utf-8") as f:
        spec = json.load(f)

    text = _render(spec, include_factory=not args.no_factory)

    out_path.parent.mkdir(parents=True, exist_ok=True)
    out_path.write_text(text, encoding="utf-8")

    print(f"Wrote {out_path}")


if __name__ == "__main__":
    main()
